// // src/routes/signin/+page.server.ts (ou où est ton action login)
// import { formSchema } from '$lib/schema/schema';
// import type { Actions, Cookies } from '@sveltejs/kit';
// import { fail, superValidate } from 'sveltekit-superforms';
// import { zod } from 'sveltekit-superforms/adapters';
// import { parse, splitCookiesString } from 'set-cookie-parser'; // Importer

// const API_BASE_URL = 'http://localhost:8000';
// const LARAVEL_SESSION_COOKIE_NAME = 'laravel_session'; // Ou récupérer dynamiquement si besoin

// // --- Fonction pour appliquer UNIQUEMENT le cookie de session Laravel ---
// function applyLaravelSessionCookie(svelteKitCookies: Cookies, setCookieHeader: string | null) {
//     if (!setCookieHeader) {
//         console.warn('Aucun header Set-Cookie reçu de Laravel.');
//         return;
//     }

//     try {
//         // splitCookiesString gère les cas où plusieurs cookies sont dans un seul header
//         const cookiesToParse = splitCookiesString(setCookieHeader);
//         const parsedCookies = parse(cookiesToParse, { map: true }); // Obtenir un objet map

//         const sessionCookieInfo = parsedCookies[LARAVEL_SESSION_COOKIE_NAME];

//         if (sessionCookieInfo) {
//             console.log(`[Login Action] Application du cookie ${LARAVEL_SESSION_COOKIE_NAME}:`, sessionCookieInfo);

//             // Utilise les attributs fournis par Laravel autant que possible
//             svelteKitCookies.set(sessionCookieInfo.name, sessionCookieInfo.value, {
//                 path: sessionCookieInfo.path || '/', // Fournir un défaut si absent
//                 domain: sessionCookieInfo.domain || 'localhost', // IMPORTANT: Assure-toi que Laravel le définit pour 'localhost' ou null, pas '.localhost'
//                 secure: sessionCookieInfo.secure ?? false, // Utilise false pour http en local
//                 httpOnly: sessionCookieInfo.httpOnly ?? true, // Généralement true pour les sessions
//                 sameSite: sessionCookieInfo.sameSite ? sessionCookieInfo.sameSite as 'lax' | 'strict' | 'none' : 'lax', // 'lax' est un bon défaut
//                 expires: sessionCookieInfo.expires, // Date d'expiration
//                 maxAge: sessionCookieInfo.maxAge // Durée de vie en secondes
//             });
//             console.log(`[Login Action] Cookie ${LARAVEL_SESSION_COOKIE_NAME} ajouté à la réponse SvelteKit.`);

//         } else {
//             console.warn(`[Login Action] Le cookie ${LARAVEL_SESSION_COOKIE_NAME} n'a pas été trouvé dans le header Set-Cookie de Laravel:`, setCookieHeader);
//         }

//          // Optionnel : Gérer XSRF-TOKEN si nécessaire ici aussi, mais souvent géré par le premier appel
//         const xsrfCookieInfo = parsedCookies['XSRF-TOKEN'];
//          if (xsrfCookieInfo) {
//              console.log(`[Login Action] Application du cookie XSRF-TOKEN:`, xsrfCookieInfo);
//               svelteKitCookies.set(xsrfCookieInfo.name, decodeURIComponent(xsrfCookieInfo.value), { // Décode la valeur XSRF
//                  path: xsrfCookieInfo.path || '/',
//                  domain: xsrfCookieInfo.domain || 'localhost',
//                  secure: xsrfCookieInfo.secure ?? false,
//                  httpOnly: false, // XSRF doit être lisible par JS
//                  sameSite: xsrfCookieInfo.sameSite ? xsrfCookieInfo.sameSite as 'lax' | 'strict' | 'none' : 'lax',
//                  expires: xsrfCookieInfo.expires,
//                  maxAge: xsrfCookieInfo.maxAge
//              });
//          }


//     } catch (error) {
//         console.error("Erreur lors du parsing ou de l'application des cookies:", error);
//         console.error("Header Set-Cookie reçu:", setCookieHeader);
//     }
// }
// // --- Fin de la fonction ---

// export const load = async () => {
//     return {
//         form: await superValidate(zod(formSchema))
//     };
// };

// export const actions: Actions = {
//     default: async ({ cookies, request }) => {
//         const form = await superValidate(request, zod(formSchema));
//         if (!form.valid) {
//             return fail(400, { form });
//         }

//         let xsrfToken = ''; // Initialiser

//         try {
//             // 1. Récupération CSRF (Optionnel si déjà fait, mais bon pour être sûr)
//             //    IMPORTANT : Utiliser les cookies déjà présents dans la requête du navigateur
//             const initialClientCookies = request.headers.get('cookie') || ''; // Récupère les cookies du NAVIGATEUR

//             console.log('[Login Action] Appel /sanctum/csrf-cookie...');
//             const csrfResponse = await fetch(`${API_BASE_URL}/sanctum/csrf-cookie`, {
//                  method: 'GET', // C'est une requête GET
//                  headers: {
//                      // Transmet les cookies du navigateur existants à Laravel
//                      'Cookie': initialClientCookies,
//                      'Origin': 'http://localhost:5173', // Important pour Sanctum
//                      'Referer': `http://localhost:5173${new URL(request.url).pathname}` // Important pour Sanctum
//                  },
//                  // credentials: 'omit' // On gère les cookies manuellement via header
//             });

//             // SvelteKit ne voit pas directement les cookies définis par cet appel 'fetch'.
//             // Il faut lire le header 'set-cookie' de la réponse CSRF
//             const csrfSetCookieHeader = csrfResponse.headers.get('set-cookie');
//             if (csrfSetCookieHeader) {
//                 console.log('[Login Action] Header Set-Cookie reçu de csrf-cookie:', csrfSetCookieHeader);
//                 const csrfCookies = parse(splitCookiesString(csrfSetCookieHeader), { map: true });
//                 if (csrfCookies['XSRF-TOKEN']) {
//                     xsrfToken = decodeURIComponent(csrfCookies['XSRF-TOKEN'].value); // Décode le token
//                     console.log('[Login Action] XSRF-TOKEN obtenu:', xsrfToken);
//                     // Applique le cookie XSRF immédiatement pour la requête suivante
//                     cookies.set('XSRF-TOKEN', xsrfToken, {
//                         path: csrfCookies['XSRF-TOKEN'].path || '/',
//                         domain: csrfCookies['XSRF-TOKEN'].domain || 'localhost',
//                         secure: csrfCookies['XSRF-TOKEN'].secure ?? false,
//                         httpOnly: false, // JS doit pouvoir le lire
//                         sameSite: csrfCookies['XSRF-TOKEN'].sameSite ? csrfCookies['XSRF-TOKEN'].sameSite as 'lax' | 'strict' | 'none' : 'lax',
//                         expires: csrfCookies['XSRF-TOKEN'].expires
//                     });
//                 } else {
//                      console.warn('[Login Action] XSRF-TOKEN non trouvé dans la réponse de csrf-cookie.');
//                 }
//             } else if (initialClientCookies.includes('XSRF-TOKEN=')) {
//                 // Si le cookie existait déjà et n'a pas été renouvelé, on essaie de l'extraire
//                 const match = initialClientCookies.match(/XSRF-TOKEN=([^;]+)/);
//                 if (match && match[1]) {
//                      xsrfToken = decodeURIComponent(match[1]);
//                      console.log('[Login Action] Utilisation du XSRF-TOKEN existant:', xsrfToken);
//                 }
//             }

//             if (!xsrfToken) {
//                  console.error("[Login Action] Échec de l'obtention du XSRF Token.");
//                  return fail(500, { form, message: "CSRF Token error" });
//             }


//             // 2. Authentification
//             console.log('[Login Action] Appel /login avec XSRF-TOKEN:', xsrfToken);
//              // Construire le header Cookie pour l'appel /login
//              // Inclure le XSRF-TOKEN fraîchement obtenu/confirmé et tout autre cookie pertinent (peut-être la session si elle existait?)
//              let loginCookieHeader = initialClientCookies; // Commence avec les cookies du navigateur
//              // Assure-toi que le XSRF-TOKEN qu'on va envoyer est le bon
//              loginCookieHeader = loginCookieHeader.replace(/XSRF-TOKEN=[^;]+;?\s*/, ''); // Enlève l'ancien s'il existe
//              loginCookieHeader = `XSRF-TOKEN=${encodeURIComponent(xsrfToken)}; ${loginCookieHeader}`; // Ajoute le nouveau/confirmé

//             const authResponse = await fetch(`${API_BASE_URL}/login`, {
//                 method: 'POST',
//                 headers: {
//                     'Content-Type': 'application/json',
//                     'Accept': 'application/json',
//                     'X-XSRF-TOKEN': xsrfToken, // Header X-XSRF-TOKEN
//                     'Cookie': loginCookieHeader,  // Envoie les cookies nécessaires (surtout XSRF)
//                     'Origin': 'http://localhost:5173', // Important pour Sanctum
//                     'Referer': `http://localhost:5173${new URL(request.url).pathname}` // Important pour Sanctum
//                 },
//                 body: JSON.stringify(form.data),
//                 // credentials: 'omit' // On gère les cookies manuellement via header
//             });

//             // 3. Gestion réponse
//             if (!authResponse.ok) {
//                 console.error(`[Login Action] Échec du login. Statut: ${authResponse.status}`);
//                 const errorData = await authResponse.json().catch(() => ({ message: 'Login failed' }));
//                 return fail(authResponse.status, { form, message: errorData.message || 'Authentication failed' });
//             }

//              console.log('[Login Action] Login réussi. Statut:', authResponse.status);
//             const responseData = await authResponse.json();

//             // 4. Mise à jour cookies (UNIQUEMENT laravel_session)
//             const laravelSetCookie = authResponse.headers.get('set-cookie');
//             console.log('[Login Action] Header Set-Cookie reçu de /login:', laravelSetCookie);
//             applyLaravelSessionCookie(cookies, laravelSetCookie); // Utilise la fonction ciblée

//             // Retourne succès (Superforms gère l'état via onUpdate)
//             // Ne pas retourner { form } en cas de succès, sinon Superforms pense qu'il y a une erreur de validation
//             return { status: 200, data: responseData }; // Envoyer les données utilisateur si besoin

//         } catch (error: any) {
//             console.error('[Login Action] Erreur inattendue:', error);
//             return fail(500, { form, message: error.message || 'An unexpected error occurred' });
//         }
//     }
// };


import { formSchema } from '$lib/schema/schema';
import type { Actions } from '@sveltejs/kit';
import { fail, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';

const API_BASE_URL = 'http://localhost:8000';


export const load = async () => {
	    return {
	        form: await superValidate(zod(formSchema))
	    };
	};


export const actions: Actions = {
    default: async ({ cookies, request }) => {
        const form = await superValidate(request, zod(formSchema));
        
        if (!form.valid) {
            return fail(400, { form });
        }

        try {
            // 1. Récupération CSRF
            const csrfResponse = await fetch(`${API_BASE_URL}/sanctum/csrf-cookie`, {
                credentials: 'include'
            });

            // 2. Authentification
            const endpoint = form.data.isRegister ? '/api/register' : '/api/login';
            const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(form.data),
                credentials: 'include'
            });
			console.log("USER :",response);
            if (!response.ok) {
                const error = await response.json();
                return fail(response.status, { form, error });
            }
			console.log("USER :",response);

            return { form };

        } catch (error) {
            return fail(500, { form });
        }
    }
};